<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TCP/IP网络编程：理解网络编程和套接字</title>
    <link href="/2024/11/04/net-code/"/>
    <url>/2024/11/04/net-code/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-IP网络编程：理解网络编程和套接字"><a href="#TCP-IP网络编程：理解网络编程和套接字" class="headerlink" title="TCP&#x2F;IP网络编程：理解网络编程和套接字"></a>TCP&#x2F;IP网络编程：理解网络编程和套接字</h1><p>网络编程又叫做套接字编程，是因为在网络编程中依赖使用套接字(socket),网络编程一般是C&#x2F;S架构，即客户端&#x2F;服务器模式，在服务器端依赖套接字绑定自身接口，并开启监听客户端连接，然后进行读写操作；客户端则依赖套接字进行接口连接，以进行收发操作。</p><h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><h3 id="服务器端遵循以下步骤进行搭建"><a href="#服务器端遵循以下步骤进行搭建" class="headerlink" title="服务器端遵循以下步骤进行搭建"></a>服务器端遵循以下步骤进行搭建</h3><ol><li>创建套接字</li><li>绑定监听端口</li><li>开始监听</li><li>接受连接</li><li>进行读写操作</li><li>关闭连接</li></ol><p>下面是创建服务器端通讯的实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//步骤1：创建套接字</span><br>    <span class="hljs-type">int</span> server_sock;<br>    server_sock = socket(PF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (server_sock == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;socket() error&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//步骤2：绑定监听端口</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_addr</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;server_addr,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(server_addr));<br>    server_addr.sin_family = AF_INET;<br>    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);<br>    server_addr.sin_port = htons(atoi(<span class="hljs-string">&quot;3333&quot;</span>));<br>    <span class="hljs-keyword">if</span> (bind(server_sock,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;server_addr,<span class="hljs-keyword">sizeof</span>(server_addr)) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;bind() error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//步骤3：开启监听</span><br>    <span class="hljs-keyword">if</span> (listen(server_sock,<span class="hljs-number">5</span>) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;listen() error&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//步骤4：接受连接</span><br>    <span class="hljs-type">int</span> accept_sock;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> <span class="hljs-title">accept_addr</span>;</span><br>    <span class="hljs-type">socklen_t</span> len = <span class="hljs-keyword">sizeof</span>(accept_addr);<br>    accept_sock = accept(server_sock,&amp;accept_addr,&amp;len);<br>    <span class="hljs-keyword">if</span> (accept_sock == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;accept() error&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//步骤5：开始通讯</span><br>    <span class="hljs-type">char</span> message[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">if</span> (read(accept_sock,message,<span class="hljs-number">10</span>) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;read() error&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read message is %s\n&quot;</span>,message);<br>    <span class="hljs-keyword">if</span> (write(accept_sock,message,<span class="hljs-number">10</span>) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;write() error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//步骤6：关闭连接</span><br>    close(accept_sock);<br>    close(server_sock);<br></code></pre></td></tr></table></figure><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="客户端遵循以下步骤进行搭建"><a href="#客户端遵循以下步骤进行搭建" class="headerlink" title="客户端遵循以下步骤进行搭建"></a>客户端遵循以下步骤进行搭建</h3><ol><li>创建套接字</li><li>指定端口连接</li><li>进行通讯</li><li>关闭连接</li></ol><p>下面是创建客户端通讯的实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//步骤1：创建套接字</span><br>    <span class="hljs-type">int</span> client_sock;<br>    client_sock = socket(PF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (client_sock == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;socket() error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//步骤2：连接端口</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">connect_addr</span>;</span><br>    connect_addr.sin_family = AF_INET;<br>    connect_addr.sin_addr.s_addr = inet_addr(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>    connect_addr.sin_port = htons(<span class="hljs-number">3333</span>);<br>    <span class="hljs-keyword">if</span> (connect(client_sock,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;connect_addr,<span class="hljs-keyword">sizeof</span>(connect_addr)) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;connect() error&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//步骤3：进行通讯</span><br>    <span class="hljs-keyword">if</span> (write(client_sock,<span class="hljs-string">&quot;nihao&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;nihao&quot;</span>)) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;write() error&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">30</span>];<br>    <span class="hljs-keyword">if</span> (read(client_sock,buffer,<span class="hljs-number">30</span>) ==  <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;read() error&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Receive message is %s\n&quot;</span>,buffer);<br>    <br>    <span class="hljs-comment">//步骤4：关闭连接</span><br>    close(client_sock);<br></code></pre></td></tr></table></figure><h2 id="网络套接字和文件描述符"><a href="#网络套接字和文件描述符" class="headerlink" title="网络套接字和文件描述符"></a>网络套接字和文件描述符</h2><p><strong>在Linux环境中，操作网络套接字和文件描述符是一样的，上面实例中使用write()和read()函数操作网络套接字，<br>用法跟操作文件描述符别无二致，操作系统自动绑定了0、1、2对应I&#x2F;O描述符的标准输入、标准输出和标准错误</strong></p>]]></content>
    
    
    <categories>
      
      <category>TCP/IP网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP和UDP</title>
    <link href="/2024/11/04/tcp-udp/"/>
    <url>/2024/11/04/tcp-udp/</url>
    
    <content type="html"><![CDATA[<h1 id="套接字类型与协议设置"><a href="#套接字类型与协议设置" class="headerlink" title="套接字类型与协议设置"></a>套接字类型与协议设置</h1><h2 id="关于socket函数"><a href="#关于socket函数" class="headerlink" title="关于socket函数"></a>关于socket函数</h2><p>在进行网络编程的时候，我们使用下列函数创建网络套接字socket</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">server_sock = socket(PF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>跳转到该函数的函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Create a new socket of type TYPE in domain DOMAIN, using</span><br><span class="hljs-comment">   protocol PROTOCOL.  If PROTOCOL is zero, one is chosen automatically.</span><br><span class="hljs-comment">   Returns a file descriptor for the new socket, or -1 for errors.  */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">socket</span> <span class="hljs-params">(<span class="hljs-type">int</span> __domain, <span class="hljs-type">int</span> __type, <span class="hljs-type">int</span> __protocol)</span> __THROW;<br></code></pre></td></tr></table></figure><ul><li>第一个参数PF_INET表示的是使用IPv4协议族，如果使用PF_IPET6则表示使用IPv6协议族</li><li>第二个参数表示的是套接字的类型，当为SOCK_STREAM时，就是指定使用TCP协议进行传输(即：创建面向连接的套接字)</li><li>第三个参数是协议的最终选择，由于大部分情况下前两个参数已经可以确定最终创建的套接字类型，这时取0即可；只有在两个套接字传输方式相同，但协议不同时，才需要第三个参数确定最终协议</li></ul><h2 id="关于TCP协议"><a href="#关于TCP协议" class="headerlink" title="关于TCP协议"></a>关于TCP协议</h2><p>TCP协议进行传输的特征</p><ol><li>传输过程中数据不会丢失(当一端read缓冲区满时，另一端会write失败，还有重传机制)</li><li>按序传输数据</li><li>传输的数据不存在数据边界(字节流传输，调用write函数和read函数的次数不是一一对应，可见该特征)</li></ol><p><strong>总结为：可靠的、按序传递的、基于字节流的、面向连接的数据传输方式</strong></p><h3 id="创建TCP套接字"><a href="#创建TCP套接字" class="headerlink" title="创建TCP套接字"></a>创建TCP套接字</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">server_sock = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);<br></code></pre></td></tr></table></figure><p>##关于UDP协议<br>TCP协议进行传输的特征</p><ol><li>强调快速传输而非顺序</li><li>传输的数据可能丢失也可能损毁</li><li>传输的数据有边界</li><li>限制每次传输数据的大小</li></ol><p><strong>总结为：不可靠的、不按序传递的、以数据的高速传输为目的的、面向消息的数据传输方式</strong></p><h3 id="创建UDP套接字"><a href="#创建UDP套接字" class="headerlink" title="创建UDP套接字"></a>创建UDP套接字</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">server_sock = socket(PF_INET,SOCK_STREAM,IPPROTO_UDP);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>TCP/IP网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于socket的常用可选配置项</title>
    <link href="/2024/11/04/socket-configure/"/>
    <url>/2024/11/04/socket-configure/</url>
    
    <content type="html"><![CDATA[<h1 id="关于socket的常用可选配置项"><a href="#关于socket的常用可选配置项" class="headerlink" title="关于socket的常用可选配置项"></a>关于socket的常用可选配置项</h1><p>我们使用下列两个函数来对创建的socket进行可选配置项的查询和设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getsockopt</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">int</span> __level, <span class="hljs-type">int</span> __optname,</span><br><span class="hljs-params">       <span class="hljs-type">void</span> *__restrict __optval,</span><br><span class="hljs-params">       <span class="hljs-type">socklen_t</span> *__restrict __optlen)</span> __THROW;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">setsockopt</span> <span class="hljs-params">(<span class="hljs-type">int</span> __fd, <span class="hljs-type">int</span> __level, <span class="hljs-type">int</span> __optname,</span><br><span class="hljs-params">       <span class="hljs-type">const</span> <span class="hljs-type">void</span> *__optval, <span class="hljs-type">socklen_t</span> __optlen)</span> __THROW;<br></code></pre></td></tr></table></figure><h2 id="1-关于SO-SNDBUF-和-SO-RCVBUF"><a href="#1-关于SO-SNDBUF-和-SO-RCVBUF" class="headerlink" title="1. 关于SO_SNDBUF 和 SO_RCVBUF"></a>1. 关于SO_SNDBUF 和 SO_RCVBUF</h2><p>这两个配置项属于SOL_SOCKET协议层，分别用于配置发送缓冲区和接收缓冲区的大小，<br>使用实例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;netinet/tcp.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_handing</span><span class="hljs-params">(<span class="hljs-type">char</span> *message)</span><br>&#123;<br>    <span class="hljs-built_in">fputs</span>(message,<span class="hljs-built_in">stderr</span>);<br>    fputc(<span class="hljs-string">&#x27;\n&#x27;</span>,<span class="hljs-built_in">stderr</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span><br>&#123;<br>    <span class="hljs-comment">//步骤1：创建套接字</span><br>    <span class="hljs-type">int</span> server_sock;<br>    server_sock = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);<br>    <span class="hljs-keyword">if</span> (server_sock == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;socket() error&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> send_buf,receive_buf;<br>    <span class="hljs-type">int</span> send_buf_size = <span class="hljs-keyword">sizeof</span>(send_buf);<br>    <span class="hljs-type">int</span> receive_buf_size = <span class="hljs-keyword">sizeof</span>(receive_buf);<br><br>    <span class="hljs-comment">//查询默认输出缓冲区大小</span><br>    <span class="hljs-keyword">if</span>(getsockopt(server_sock,SOL_SOCKET,SO_SNDBUF,(<span class="hljs-type">void</span> *)&amp;send_buf,(<span class="hljs-type">socklen_t</span> *)&amp;send_buf_size) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;getsockopt() error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//查询默认输入缓冲区大小</span><br>    <span class="hljs-keyword">if</span>(getsockopt(server_sock,SOL_SOCKET,SO_RCVBUF,(<span class="hljs-type">void</span> *)&amp;receive_buf,(<span class="hljs-type">socklen_t</span> *)&amp;receive_buf_size) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;getsockopt() error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//打印结果</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;默认输出缓冲区大小：%d\n&quot;</span>,send_buf);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;默认输入缓冲区大小：%d\n&quot;</span>,receive_buf);<br><br>    send_buf = <span class="hljs-number">4</span> * <span class="hljs-number">1024</span>;<br>    receive_buf = <span class="hljs-number">4</span> * <span class="hljs-number">1024</span>;<br><br>   <span class="hljs-comment">//设置输出缓冲区大小</span><br>    <span class="hljs-keyword">if</span>(setsockopt(server_sock,SOL_SOCKET,SO_SNDBUF,(<span class="hljs-type">void</span> *)&amp;send_buf,(<span class="hljs-type">socklen_t</span>)send_buf_size) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;setsockopt() error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//设置输入缓冲区大小</span><br>    <span class="hljs-keyword">if</span>(setsockopt(server_sock,SOL_SOCKET,SO_RCVBUF,(<span class="hljs-type">void</span> *)&amp;receive_buf,(<span class="hljs-type">socklen_t</span>)receive_buf_size) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;setsockopt() error&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//查询输出缓冲区大小</span><br>    <span class="hljs-keyword">if</span>(getsockopt(server_sock,SOL_SOCKET,SO_SNDBUF,(<span class="hljs-type">void</span> *)&amp;send_buf,(<span class="hljs-type">socklen_t</span> *)&amp;send_buf_size) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;getsockopt() error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//查询输入缓冲区大小</span><br>    <span class="hljs-keyword">if</span>(getsockopt(server_sock,SOL_SOCKET,SO_RCVBUF,(<span class="hljs-type">void</span> *)&amp;receive_buf,(<span class="hljs-type">socklen_t</span> *)&amp;receive_buf_size) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;getsockopt() error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//打印结果</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;设置之后的输出缓冲区大小：%d\n&quot;</span>,send_buf);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;设置之后的输入缓冲区大小：%d\n&quot;</span>,receive_buf);<br><br>    close(server_sock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-关于SO-REUSEADDR"><a href="#2-关于SO-REUSEADDR" class="headerlink" title="2. 关于SO_REUSEADDR"></a>2. 关于SO_REUSEADDR</h2><p>这个配置项也是在SOL_SOCKET协议层，这个参数默认值为0，即禁用端口复用<br>这样会出现一个问题，当服务器较客户端先行退出时（ctrl + c）,重新启动服务器失败，问题出在绑定端口位置（bind()函数），需要等待几分钟之后才能正确启动，原因是因为先行关闭的socket会进入time wait状态，如果服务器先行关闭，服务器绑定的端口就会进入time wait状态，导致我们在重启服务器时重用原来的端口。<br>要解决这个问题，我们可以手动开启socket的端口复用，将SO_REUSEADDR设置为1即可达到目的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;netinet/tcp.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_handing</span><span class="hljs-params">(<span class="hljs-type">char</span> *message)</span><br>&#123;<br>    <span class="hljs-built_in">fputs</span>(message,<span class="hljs-built_in">stderr</span>);<br>    fputc(<span class="hljs-string">&#x27;\n&#x27;</span>,<span class="hljs-built_in">stderr</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span><br>&#123;<br>    <span class="hljs-comment">//步骤1：创建套接字</span><br>    <span class="hljs-type">int</span> server_sock;<br>    server_sock = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);<br>    <span class="hljs-keyword">if</span> (server_sock == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;socket() error&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> option;<br>    <span class="hljs-type">socklen_t</span> opt_len;<br>    opt_len = <span class="hljs-keyword">sizeof</span>(option);<br><br>    <span class="hljs-keyword">if</span>(getsockopt(server_sock,SOL_SOCKET,SO_REUSEADDR,(<span class="hljs-type">void</span> *)&amp;option,&amp;opt_len) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;getsockopt() error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查询当前是否禁用端口复用\n&quot;</span>);<br>    <span class="hljs-keyword">switch</span> (option)<br>    &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查询当前已经禁用端口复用\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查询当前已经开启端口复用\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;错误\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    option = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//设置允许端口复用，解决服务器先行退出进入time_wait状态导致无法再次启动服务器的问题</span><br>    <span class="hljs-keyword">if</span>(setsockopt(server_sock,SOL_SOCKET,SO_REUSEADDR,(<span class="hljs-type">void</span> *)&amp;option,opt_len) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;setsockopt() error&quot;</span>);<br>    &#125;<br><br>    option = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(getsockopt(server_sock,SOL_SOCKET,SO_REUSEADDR,(<span class="hljs-type">void</span> *)&amp;option,&amp;opt_len) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;getsockopt() error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查询当前是否禁用端口复用\n&quot;</span>);<br>    <span class="hljs-keyword">switch</span> (option)<br>    &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查询当前已经禁用端口复用\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查询当前已经开启端口复用\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;错误\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    close(server_sock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-关于TCP-NODELAY"><a href="#3-关于TCP-NODELAY" class="headerlink" title="3. 关于TCP_NODELAY"></a>3. 关于TCP_NODELAY</h2><p>这个配置项是属于IPROTO_TCP协议层的，用于开启或禁用Nagle算法，默认值是0，即默认是开启Nagle算法的</p><p>使用实例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> option;<br><span class="hljs-type">socklen_t</span> opt_len;<br>opt_len = <span class="hljs-keyword">sizeof</span>(option);<br><br><span class="hljs-comment">//查询是否使用Nagle算法</span><br><span class="hljs-keyword">if</span>(getsockopt(server_sock,SOL_SOCKET,SO_REUSEADDR,(<span class="hljs-type">void</span> *)&amp;option,&amp;opt_len) == <span class="hljs-number">-1</span>)<br>&#123;<br>    error_handing(<span class="hljs-string">&quot;getsockopt() error&quot;</span>);<br>&#125;<br><br>option = <span class="hljs-number">1</span>;<br><span class="hljs-comment">//禁用Nagle算法 1：禁用，0（默认）：开启</span><br><span class="hljs-keyword">if</span>(setsockopt(server_sock,IPPROTO_TCP,TCP_NODELAY,(<span class="hljs-type">void</span> *)&amp;option,opt_len) == <span class="hljs-number">-1</span>)<br>&#123;<br>    error_handing(<span class="hljs-string">&quot;setsockopt() error&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>TCP/IP网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多进程案例以及僵尸进程</title>
    <link href="/2024/11/04/multi-and-zombie/"/>
    <url>/2024/11/04/multi-and-zombie/</url>
    
    <content type="html"><![CDATA[<h2 id="1-多进程案例"><a href="#1-多进程案例" class="headerlink" title="1 多进程案例"></a>1 多进程案例</h2><p>C语言在Linux环境下使用fork()函数创造一个子进程<br>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">__pid_t</span> <span class="hljs-title function_">fork</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span> __THROWNL;<br></code></pre></td></tr></table></figure><p>返回的是子进程的进程id<br>该子进程是父进程的一个进程副本，父子进程拥有独立的内存结构，只是拥有同一段运行代码而已。<br>区分子父进程的方法是：fork()函数的返回值不同，父进程的返回值是子进程的进程id(pid),子进程的返回值则是0<br>请看以下实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> global_val = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span><br>&#123;<br><br>    <span class="hljs-type">int</span> locate_val = <span class="hljs-number">100</span>;<br>    <span class="hljs-type">__pid_t</span> pid = fork();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child process pid:%d\n&quot;</span>,pid); <br><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child process running...\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;father process running...\n&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        global_val *= <span class="hljs-number">2</span>;<br>        locate_val *= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        global_val *= <span class="hljs-number">3</span>;<br>        locate_val *= <span class="hljs-number">3</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;global value:%d\n&quot;</span>,global_val);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;locate value:%d\n&quot;</span>,locate_val);<br><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child global value:%d\n&quot;</span>,global_val);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child locate value:%d\n&quot;</span>,locate_val);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;father global value:%d\n&quot;</span>,global_val);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;father locate value:%d\n&quot;</span>,locate_val);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">child</span> process pid:<span class="hljs-number">93918</span><br><span class="hljs-attribute">father</span> process running...<br><span class="hljs-attribute">global</span> value:<span class="hljs-number">30</span><br><span class="hljs-attribute">locate</span> value:<span class="hljs-number">300</span><br><span class="hljs-attribute">father</span> global value:<span class="hljs-number">30</span><br><span class="hljs-attribute">father</span> locate value:<span class="hljs-number">300</span><br><span class="hljs-attribute">child</span> process pid:<span class="hljs-number">0</span><br><span class="hljs-attribute">child</span> process running...<br><span class="hljs-attribute">global</span> value:<span class="hljs-number">20</span><br><span class="hljs-attribute">locate</span> value:<span class="hljs-number">200</span><br><span class="hljs-attribute">child</span> global value:<span class="hljs-number">20</span><br><span class="hljs-attribute">child</span> locate value:<span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><h2 id="2-僵尸进程"><a href="#2-僵尸进程" class="headerlink" title="2 僵尸进程"></a>2 僵尸进程</h2><h3 id="2-1-僵尸进程产生原因"><a href="#2-1-僵尸进程产生原因" class="headerlink" title="2.1 僵尸进程产生原因"></a>2.1 僵尸进程产生原因</h3><p>当子进程结束，未被父进程回收时，子进程就成了僵尸进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child global value:%d\n&quot;</span>,global_val);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child locate value:%d\n&quot;</span>,locate_val);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;father global value:%d\n&quot;</span>,global_val);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;father locate value:%d\n&quot;</span>,locate_val);<br>    sleep(<span class="hljs-number">30</span>);<span class="hljs-comment">//父进程阻塞</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的实例在父进程中增加阻塞，会导致子进程先行退出，这时候子进程就变成了僵尸进程。<br>僵尸进程会一直占用操作系统的进程号，后续会产生不可思议的错误。</p><p>做了父进程程序阻塞之后我们运行程序，并查看操作系统的进程(ps -au)</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">alang@ubuntu:~/tcp-uip-network-programming/chapter_5$ ps -au<br>...截取一部分...<br>alang     <span class="hljs-number"> 51538 </span> 0.0  0.1 <span class="hljs-number"> 14648 </span><span class="hljs-number"> 5764 </span>pts/3    Ss+  12:49   0:00 /usr/bin/bash --init-<br>alang     <span class="hljs-number"> 62308 </span> 0.0  0.1 <span class="hljs-number"> 14480 </span><span class="hljs-number"> 5556 </span>pts/1    Ss+  13:40   0:00 bash<br>alang     <span class="hljs-number"> 97278 </span> 0.0  0.0  <span class="hljs-number"> 2500 </span> <span class="hljs-number"> 576 </span>pts/0    S    16:28   0:00 ./process<br>**alang     <span class="hljs-number"> 97280 </span> 0.0  0.0     <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>pts/0    Z    16:28   0:00 [process] &lt;defunct&gt;**<br>alang     <span class="hljs-number"> 97354 </span> 0.0  0.0 <span class="hljs-number"> 14576 </span><span class="hljs-number"> 3276 </span>pts/0    R+   16:28   0:00 ps -au<br></code></pre></td></tr></table></figure><p>可以看到子进程被标记为Z，即僵尸进程。</p><p><strong>产生僵尸进程的原因</strong><br>由于父进程可能需要子进程退出之后的返回值，所以操作系统不会主动销毁exit或return结束的子进程。</p><p><strong>杀死僵尸进程的方法</strong><br>需要父进程接收子进程退出时返回的值才能杀死对应的僵尸进程。</p><h3 id="2-2-销毁僵尸进程的方法1：利用wait-函数"><a href="#2-2-销毁僵尸进程的方法1：利用wait-函数" class="headerlink" title="2.2 销毁僵尸进程的方法1：利用wait()函数"></a>2.2 销毁僵尸进程的方法1：利用wait()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">__pid_t</span> <span class="hljs-title function_">wait</span> <span class="hljs-params">(<span class="hljs-type">int</span> *__stat_loc)</span>;<br></code></pre></td></tr></table></figure><p>请看一下实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">int</span> global_val = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span><br>&#123;<br><br>    <span class="hljs-type">int</span> locate_val = <span class="hljs-number">100</span>;<br>    <span class="hljs-type">__pid_t</span> pid = fork();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child process pid:%d\n&quot;</span>,pid); <br><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child process running...\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;father process running...\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">int</span> status;<br>        wait(&amp;status);<br>        <span class="hljs-keyword">if</span> (WIFEXITED(status))<span class="hljs-comment">//检测是否正常退出</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;子进程的退出返回值 %d\n&quot;</span>,WEXITSTATUS(status));<span class="hljs-comment">//打印子进程退出返回值</span><br>        &#125;   <br>    <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;father global value:%d\n&quot;</span>,global_val);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;father locate value:%d\n&quot;</span>,locate_val);<br>        sleep(<span class="hljs-number">30</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino">[<span class="hljs-number">1</span>] <span class="hljs-number">106441</span><br>child process pid:<span class="hljs-number">106443</span><br>father process running...<br>child process pid:<span class="hljs-number">0</span><br>child process running...<br>子进程的退出返回值 <span class="hljs-number">0</span><br>father global value:<span class="hljs-number">10</span><br>father locate value:<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p><strong>此时使用ps au 查看进程，发现没有僵尸进程。</strong></p><p>调用wait()函数将子进程的状态信息写入到传入的形参指针中，由于含有多个状态信息，所以需要分别使用不同的宏来提取我们需要的结果</p><ul><li><p>WIFEXITED(__stat_loc): 检查子进程是否正常退出。如果返回非零值，表示子进程是因调用 exit() 或返回语句结束的。</p></li><li><p>WEXITSTATUS(__stat_loc): 如果子进程是正常退出的（即 WIFEXITED(status)返回非零值），这个宏会返回子进程的退出代码（exit code），这是由 exit() 函数的参数或 return 语句的值决定的。</p></li><li><p>WIFSIGNALED(__stat_loc): 检查子进程是否是因接收到信号而终止的。如果返回非零值，表示子进程是被信号终止的。</p></li><li><p>WTERMSIG(__stat_loc): 如果子进程是因为信号而终止的（返回非零值），这个宏会返回导致子进程终止的信号。</p></li></ul><p>也就是说，当调用wait函数之后，我们将总是使用这些宏来提取我们需要的信息</p><p><strong>使用wait函数有一个问题，就是调用wait()函数之后，父进程将会阻塞等待，直到由子进程退出。</strong></p><h3 id="2-3-销毁僵尸进程的方法2：利用waitpid-函数"><a href="#2-3-销毁僵尸进程的方法2：利用waitpid-函数" class="headerlink" title="2.3 销毁僵尸进程的方法2：利用waitpid()函数"></a>2.3 销毁僵尸进程的方法2：利用waitpid()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">__pid_t</span> <span class="hljs-title function_">waitpid</span> <span class="hljs-params">(<span class="hljs-type">__pid_t</span> __pid, <span class="hljs-type">int</span> *__stat_loc, <span class="hljs-type">int</span> __options)</span>;<br></code></pre></td></tr></table></figure><p>相应参数作用如下：</p><ul><li>pid：指定要等待的子进程的 PID，如果填为-1，则是等待任意子进程。</li><li>__stat_loc：指向一个整数变量的指针，用于接收子进程的退出状态。</li><li>options：指定等待操作的选项。常用的选项有 WNOHANG（使 waitpid() 调用非阻塞）、WUNTRACED（使 waitpid() 能够返回停止的子进程）。</li></ul><p>相应修改部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> status;<br><span class="hljs-keyword">while</span>(!waitpid(<span class="hljs-number">-1</span>,&amp;status,WNOHANG))&#123;<br>    <span class="hljs-comment">//这里运行父进程的代码段</span><br>    <br>&#125;<br><span class="hljs-keyword">if</span> (WIFEXITED(status))<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;子进程的退出返回值：%d \n&quot;</span>,WEXITSTATUS(status));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>程序输出和现象同wait()函数实例</strong></p><h3 id="2-4-销毁僵尸进程的方法3：信号处理signal"><a href="#2-4-销毁僵尸进程的方法3：信号处理signal" class="headerlink" title="2.4 销毁僵尸进程的方法3：信号处理signal()"></a>2.4 销毁僵尸进程的方法3：信号处理signal()</h3><p>上面分别提到了wait()函数和waitpid函数，wait()函数是阻塞式等待，waitpid函数是非阻塞式等待，但是父进程轮询时每次都要执行一遍waitpid函数，这样的调用开销是没有必要的，<strong>我们可以使用信号处理的方式</strong>。当操作系统收到子进程退出的信号时，通知父进程做相应处理即可。<br>即在父进程中设置子进程退出信号的回调函数，在回调函数中接收子进程退出返回值。</p><p>信号处理我们可以使用signal()函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">__sighandler_t</span> <span class="hljs-title function_">signal</span> <span class="hljs-params">(<span class="hljs-type">int</span> __sig, <span class="hljs-type">__sighandler_t</span> __handler)</span><br>     __THROW;<br></code></pre></td></tr></table></figure><p>下面是一个使用实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">KeyBoardHandle</span><span class="hljs-params">()</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Ctrl + C\n&quot;</span>);&#125;;<br><span class="hljs-type">void</span> <span class="hljs-title function_">AlarmHandle</span><span class="hljs-params">()</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Alarm Dingling\n&quot;</span>);&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span><br>&#123;<br><br>    signal(SIGINT,KeyBoardHandle);<span class="hljs-comment">//注册Ctrl + C信号</span><br>    signal(SIGALRM,AlarmHandle);<span class="hljs-comment">//注册闹钟回调</span><br>    <br>    alarm(<span class="hljs-number">10</span>);<span class="hljs-comment">//开启十秒钟的闹钟</span><br>    sleep(<span class="hljs-number">200</span>);<span class="hljs-comment">//睡眠200秒</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>当闹钟到期或者Ctrl+C按下时，程序都会终止：尽管现在程序处在于sleep()函数的阻塞状态，但只要产生信号，为了调用信号处理器，就会唤醒调用sleep()函数进入阻塞状态的进程。</strong></p><p>我们可以使用信号处理函数接收子进程返回值，以此销毁僵尸进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ChildExitHandle</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;子进程退出\n&quot;</span>);<br>    <span class="hljs-type">int</span> status;<br><br>    <span class="hljs-type">pid_t</span> pid = waitpid(<span class="hljs-number">-1</span>,&amp;status,WNOHANG);<br><br>    <span class="hljs-keyword">if</span> (WIFEXITED(status))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;子进程id:%d \n&quot;</span>,pid);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;子进程的退出返回值：%d \n&quot;</span>,WEXITSTATUS(status));<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span><br>&#123;<br>    signal(SIGCLD,ChildExitHandle);<span class="hljs-comment">//注册子进程退出信号</span><br>    <br>    <span class="hljs-type">__pid_t</span> pid = fork();<br>    <br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        sleep(<span class="hljs-number">10</span>);<span class="hljs-comment">//子进程睡眠10秒</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        sleep(<span class="hljs-number">200</span>);<span class="hljs-comment">//父进程睡眠200秒</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述实例在子进程睡眠10秒到期之后，父进程收到SIGCLD信号，然后调用对应的回调函数，在回调函数中使用waitpid接收子进程返回的相关信息。</p><h3 id="2-5-销毁僵尸进程的方法4：信号处理sigaction"><a href="#2-5-销毁僵尸进程的方法4：信号处理sigaction" class="headerlink" title="2.5 销毁僵尸进程的方法4：信号处理sigaction()"></a>2.5 销毁僵尸进程的方法4：信号处理sigaction()</h3><p>上述中可以使用signal()函数以信号处理的方式处理僵尸进程。由于signal()函数在不同UNIX操作系统中可能存在区别，所以可以使用完全相同的sigaction()函数来在替代。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sigaction</span> <span class="hljs-params">(<span class="hljs-type">int</span> __sig, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sigaction *__restrict __act,</span><br><span class="hljs-params">      <span class="hljs-keyword">struct</span> sigaction *__restrict __oact)</span> __THROW;<br></code></pre></td></tr></table></figure><ul><li>__sig:对应要处理的信号</li><li>__act:指向 sigaction 结构的指针,用于存储回调函数的信息</li><li>__oact:指向 sigaction 结构的指针，用于存储信号的旧处理行为。如果不需要旧的处理行为，这个参数可以是 NULL</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> &#123;</span><br><span class="hljs-type">__sighandler_t</span> sa_handler;<span class="hljs-comment">//信号处理函数</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sa_flags;    <span class="hljs-comment">//信号处理选项</span><br><span class="hljs-type">__sigrestore_t</span> sa_restorer;<span class="hljs-comment">//不使用</span><br><span class="hljs-type">sigset_t</span> sa_mask;<span class="hljs-comment">//在信号处理函数执行期间需要屏蔽的信号集</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>下面直接来看使用实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/sigaction.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ChildExitHandle</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;子进程退出\n&quot;</span>);<br>    <span class="hljs-type">int</span> status;<br><br>    <span class="hljs-type">pid_t</span> pid = waitpid(<span class="hljs-number">-1</span>,&amp;status,WNOHANG);<br><br>    <span class="hljs-keyword">if</span> (WIFEXITED(status))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;子进程id:%d \n&quot;</span>,pid);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;子进程的退出返回值：%d \n&quot;</span>,WEXITSTATUS(status));<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">sig</span>;</span><span class="hljs-comment">//声明配置结构体</span><br>    sig.sa_handler = ChildExitHandle;<span class="hljs-comment">//设置信号回调函数</span><br>    <br>    sigaction(SIGCLD,&amp;sig,<span class="hljs-literal">NULL</span>);<span class="hljs-comment">//绑定信号与信号回调函数</span><br>    <span class="hljs-type">__pid_t</span> pid = fork();<br>    <br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        sleep(<span class="hljs-number">10</span>);<span class="hljs-comment">//子进程睡眠10秒</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        sleep(<span class="hljs-number">200</span>);<span class="hljs-comment">//父进程睡眠200秒</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实例效果同sigal函数</strong></p><p>参考链接：<a href="https://blog.csdn.net/m0_53115174/article/details/139199516">《TCP&#x2F;IP网络编程》（第十章）多进程服务器端</a></p>]]></content>
    
    
    <categories>
      
      <category>TCP/IP网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多进程回声服务器</title>
    <link href="/2024/11/04/echo-server/"/>
    <url>/2024/11/04/echo-server/</url>
    
    <content type="html"><![CDATA[<h2 id="服务器搭建思路"><a href="#服务器搭建思路" class="headerlink" title="服务器搭建思路"></a>服务器搭建思路</h2><ol><li>处理僵尸进程</li><li>生成服务端</li><li>循环接收客服端连接并开辟新进程处理新连接</li></ol><p><strong>以下是服务器实例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;netinet/tcp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/sigaction.h&gt;</span></span><br><br><span class="hljs-comment">//子进程退出信号回调函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ChildExitHandle</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">//使用waitpid()函数</span><br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-type">pid_t</span> pid = waitpid(<span class="hljs-number">-1</span>,&amp;status,WNOHANG);<span class="hljs-comment">//监控任意子进程、状态信息、非阻塞</span><br>    <span class="hljs-keyword">if</span> (WIFEXITED(status))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child process exited.\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The child process&#x27;s id is %d\n&quot;</span>,WEXITSTATUS(status));<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-comment">//错误处理</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_handing</span><span class="hljs-params">(<span class="hljs-type">char</span> *message)</span><br>&#123;<br>    <span class="hljs-built_in">fputs</span>(message,<span class="hljs-built_in">stderr</span>);<br>    fputc(<span class="hljs-string">&#x27;\n&#x27;</span>,<span class="hljs-built_in">stderr</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span><br>&#123;<br>    <span class="hljs-comment">//步骤1：处理僵尸进程 -&gt; 使用sigaction()函数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">sig_cfg</span>;</span><br>    sig_cfg.sa_handler = ChildExitHandle;<br>    sigaction(SIGCLD,&amp;sig_cfg,<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">//步骤2.1：生成服务端socket</span><br>    <span class="hljs-type">int</span> server_sock;<br>    server_sock = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);<br>    <span class="hljs-keyword">if</span> (server_sock == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;socket() error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//步骤2.2：绑定监听端口</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_addr</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;server_addr,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(server_addr));<br>    server_addr.sin_family = AF_INET;<br>    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);<br>    server_addr.sin_port = htons(atoi(<span class="hljs-string">&quot;3333&quot;</span>));<br>    <span class="hljs-keyword">if</span> (bind(server_sock,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;server_addr,<span class="hljs-keyword">sizeof</span>(server_addr)) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;bind() error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//步骤2.3：开启端口监听</span><br>    <span class="hljs-keyword">if</span> (listen(server_sock,<span class="hljs-number">5</span>) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;listen() error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//步骤3：循环接收客服端连接并开辟新进程处理新连接</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">//步骤3.1：接受连接</span><br>        <span class="hljs-type">int</span> accept_sock;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> <span class="hljs-title">accept_addr</span>;</span><br>        <span class="hljs-type">socklen_t</span> len = <span class="hljs-keyword">sizeof</span>(accept_addr);<br>        accept_sock = accept(server_sock,&amp;accept_addr,&amp;len);<span class="hljs-comment">//第二个参数存储接入的客户端的地址信息</span><br>        <span class="hljs-keyword">if</span> (accept_sock == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-comment">//error_handing(&quot;accept() error&quot;);</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;New client connected...\n&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//步骤3.2：开辟新进程与客户端交互</span><br>        <span class="hljs-type">pid_t</span> pid = fork();<br><br>        <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<span class="hljs-comment">//子进程</span><br>        &#123;<br>            <span class="hljs-comment">//子进程同时也复制了父进程的server_sock，要关闭</span><br>            close(server_sock);<br><br>            <span class="hljs-comment">//步骤3.3：开始交互</span><br>            <span class="hljs-type">const</span> <span class="hljs-type">int</span> message_size = <span class="hljs-number">10</span>;<br>            <span class="hljs-type">char</span> message[message_size];<br>            <span class="hljs-type">int</span> read_len = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>((read_len=read(accept_sock, message, message_size))!=<span class="hljs-number">0</span>)<br>                write(accept_sock, message, read_len);<br><br>            <span class="hljs-comment">//步骤3.3：交互完毕，关闭连接</span><br>            close(accept_sock);<br><br>            <span class="hljs-comment">//步骤3.4：子进程退出</span><br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><span class="hljs-comment">//父进程</span><br>        &#123;<br>            <span class="hljs-comment">//父进程同时也包含了子进程的accept_sock，要关闭</span><br>            close(accept_sock);<br>        &#125;<br>        <br>    &#125;<br>    close(server_sock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端实例：采用分割I&#x2F;O的方法，将输入和出输出分割，简化逻辑</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span> </span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 30</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_handling</span><span class="hljs-params">(<span class="hljs-type">char</span> *message)</span>; <br><span class="hljs-type">void</span> <span class="hljs-title function_">read_routline</span><span class="hljs-params">(<span class="hljs-type">int</span> sock, <span class="hljs-type">char</span> *buf)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">write_routline</span><span class="hljs-params">(<span class="hljs-type">int</span> sock, <span class="hljs-type">char</span> *buf)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> <br>&#123;<br>    <br>    <span class="hljs-type">int</span> sock; <br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serv_addr</span>;</span><br>    <span class="hljs-type">char</span> message[BUF_SIZE]; <br>    <span class="hljs-type">int</span> str_len,i; <br><br>    <br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>); <br>    &#125;<br><br>    <span class="hljs-comment">//步骤1：创建套接字</span><br>    sock = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (sock == <span class="hljs-number">-1</span>) <br>        error_handling(<span class="hljs-string">&quot;socket() error&quot;</span>); <br><br>    <span class="hljs-comment">//步骤2：连接端口</span><br>    <span class="hljs-built_in">memset</span>(&amp;serv_addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(serv_addr));<br>    serv_addr.sin_family = AF_INET; <span class="hljs-comment">// 地址族设置为IPv4</span><br>    serv_addr.sin_addr.s_addr = inet_addr(argv[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 设置服务器IP地址</span><br>    serv_addr.sin_port = htons(atoi(argv[<span class="hljs-number">2</span>])); <span class="hljs-comment">// 设置服务器端口号</span><br><br>    <span class="hljs-comment">// 发送连接请求</span><br>    <span class="hljs-keyword">if</span> (connect(sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="hljs-keyword">sizeof</span>(serv_addr)) == <span class="hljs-number">-1</span>)<br>        error_handling(<span class="hljs-string">&quot;connect() error&quot;</span>); <br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Connected ok\n&quot;</span>);<br>        &#125;<br>    <br>    <span class="hljs-comment">//步骤3：进行通讯</span><br>    pid=fork();<br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)&#123;<br>        write_routline(sock,message);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        read_routline(sock,message);<br>        close(sock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_handling</span><span class="hljs-params">(<span class="hljs-type">char</span>* message)</span>&#123;<br>    <span class="hljs-built_in">fputs</span>(message, <span class="hljs-built_in">stderr</span>); <br>    fputc(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-built_in">stderr</span>); <br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>); <br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">write_routline</span><span class="hljs-params">(<span class="hljs-type">int</span> sock, <span class="hljs-type">char</span> *buf)</span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        fgets(buf, BUF_SIZE, <span class="hljs-built_in">stdin</span>);<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(buf,<span class="hljs-string">&quot;q\n&quot;</span>)||!<span class="hljs-built_in">strcmp</span>(buf,<span class="hljs-string">&quot;Q\n&quot;</span>))&#123;<br>            shutdown(sock, SHUT_WR);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        write(sock, buf, <span class="hljs-built_in">strlen</span>(buf));<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">read_routline</span><span class="hljs-params">(<span class="hljs-type">int</span> sock, <span class="hljs-type">char</span> *buf)</span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-type">int</span> str_len=read(sock, buf, BUF_SIZE);<br>        <span class="hljs-keyword">if</span>(str_len==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        buf[str_len]=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Message from server:%s&quot;</span>, buf);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>使用客户端 ：.&#x2F;client “服务端ip” “端口”</strong></p>]]></content>
    
    
    <categories>
      
      <category>TCP/IP网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>select函数、I/O复用、并发服务器</title>
    <link href="/2024/11/04/select/"/>
    <url>/2024/11/04/select/</url>
    
    <content type="html"><![CDATA[<h1 id="select函数、I-O复用、并发服务器"><a href="#select函数、I-O复用、并发服务器" class="headerlink" title="select函数、I&#x2F;O复用、并发服务器"></a>select函数、I&#x2F;O复用、并发服务器</h1><p><strong>select函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">select</span> <span class="hljs-params">(<span class="hljs-type">int</span> __nfds, fd_set *__restrict __readfds,</span><br><span class="hljs-params">   fd_set *__restrict __writefds,</span><br><span class="hljs-params">   fd_set *__restrict __exceptfds,</span><br><span class="hljs-params">   <span class="hljs-keyword">struct</span> timeval *__restrict __timeout)</span>;<br></code></pre></td></tr></table></figure><p><strong>参数介绍：</strong></p><ol><li>int __nfds:</li></ol><ul><li>这是需要监视的文件描述符集合中最大的文件描述符值加1。因为文件描述符是从0开始分配的，所以如果你有文件描述符3，那么你实际上是在监视0, 1, 2, 和3这四个文件描述符（尽管可能其中一些并没有被使用）。因此，这个参数应该设置为4（即最大文件描述符+1）。<br>操作fe_set集合统一的宏来处理：<br>• FD_SET(fd, &amp;set): 将文件描述符fd添加到set集合中。<br>• FD_CLR(fd, &amp;set): 从set集合中删除文件描述符fd。<br>• FD_ISSET(fd, &amp;set): 检查fd是否在set集合中。<br>• FD_ZERO(&amp;set): 清空set集合。</li></ul><ol start="2"><li>fd_set *__restrict __readfds:</li></ol><ul><li>这是一个指向文件描述符集合的指针，该集合中的文件描述符被监视以查看它们是否可读。如果不需要监视任何文件描述符是否可读，这个参数可以设置为NULL。</li></ul><ol start="3"><li>fd_set *__restrict __writefds:</li></ol><ul><li>类似于 __readfds，这个参数指向一个文件描述符集合，集合中的文件描述符被监视以查看它们是否可写。如果不需要监视任何文件描述符是否可写，这个参数可以设置为NULL。</li></ul><ol start="4"><li>fd_set *__restrict __exceptfds:</li></ol><ul><li>这也是一个指向文件描述符集合的指针，集合中的文件描述符被监视以查看是否有异常条件发生（比如带外数据到达）。如果不需要监视任何文件描述符的异常条件，这个参数可以设置为NULL。</li></ul><ol start="5"><li>struct timeval *__restrict __timeout:</li></ol><ul><li>这是一个指向 timeval 结构体的指针，该结构体指定了 select 函数等待的最长时间。如果设置为NULL，select 将无限期地等待，直到某个文件描述符准备好。</li><li>timeval 结构体通常包含两个成员：tv_sec（秒）和 tv_usec（微秒），用于指定时间间隔。</li></ul><ol start="6"><li>返回值：</li></ol><ul><li>select 函数返回准备好的文件描述符的总数（即可读、可写或有异常条件的文件描述符总数）。</li><li>如果返回-1，则表示发生了错误（此时应该检查 errno 来确定错误的具体原因）。</li><li>如果返回0，这表示超时。</li></ul><p><strong>可以直接看使用实例：可以使用任意客户端代码进行测试</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LISTEN_NUM 10</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_handing</span><span class="hljs-params">(<span class="hljs-type">char</span> *message)</span><br>&#123;<br>    <span class="hljs-built_in">fputs</span>(message,<span class="hljs-built_in">stderr</span>);<br>    fputc(<span class="hljs-string">&#x27;\n&#x27;</span>,<span class="hljs-built_in">stderr</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span><br>&#123;<br>    <span class="hljs-comment">//步骤1：创建套接字</span><br>    <span class="hljs-type">int</span> server_sock;<br>    server_sock = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);<br>    <span class="hljs-keyword">if</span> (server_sock == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;socket() error&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//步骤2：绑定监听端口</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_addr</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;server_addr,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(server_addr));<br>    server_addr.sin_family = AF_INET;<br>    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);<br>    server_addr.sin_port = htons(atoi(<span class="hljs-string">&quot;3333&quot;</span>));<br>    <span class="hljs-keyword">if</span> (bind(server_sock,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;server_addr,<span class="hljs-keyword">sizeof</span>(server_addr)) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;bind() error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//步骤3：开启监听</span><br>    <span class="hljs-keyword">if</span> (listen(server_sock,LISTEN_NUM) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;listen() error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//步骤4：做select调用之前的准备</span><br><br>    <span class="hljs-comment">//步骤4.1：初始化sock 集合</span><br>    fd_set fd_reads,fd_copy;<span class="hljs-comment">//经过select函数之后，需要比较fd_set中的位是否改变，所以这里总是需要两个fd_set变量</span><br>    FD_ZERO(&amp;fd_reads);<br>    <br>    <span class="hljs-comment">//步骤4.2：将server_sock加入到集合中</span><br>    FD_SET(server_sock,&amp;fd_reads);<br><br>    <span class="hljs-comment">//步骤4.3：初始化最大值</span><br>    <span class="hljs-type">int</span> fd_max = server_sock;<span class="hljs-comment">//定义最大的socket</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        fd_copy = fd_reads;<br><br>        <span class="hljs-comment">//步骤4.4：设置超时时间</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">time_out</span>;</span><br>        time_out.tv_sec = <span class="hljs-number">5</span>;<br>        <br>        <span class="hljs-comment">//步骤5：调用select函数，讨论其返回值</span><br>        <span class="hljs-type">int</span> activity_sockets = select(fd_max + <span class="hljs-number">1</span>,&amp;fd_copy,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,&amp;time_out);<br><br>        <span class="hljs-keyword">if</span> (activity_sockets == <span class="hljs-number">-1</span>)<span class="hljs-comment">//发生错误，退出</span><br>        &#123;<br>            error_handing(<span class="hljs-string">&quot;select() error&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (activity_sockets == <span class="hljs-number">0</span>)<span class="hljs-comment">//超时</span><br>        &#123;<br>            <span class="hljs-comment">//选择继续运行</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Time out.\n&quot;</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; fd_max + <span class="hljs-number">1</span>; i++)<span class="hljs-comment">//比较是否对应的事件位是否改变</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (FD_ISSET(i,&amp;fd_copy))<span class="hljs-comment">//说明i事件活动了</span><br>            &#123;   <br>                <span class="hljs-keyword">if</span>(i == server_sock)<span class="hljs-comment">//说明有新的客户端接入</span><br>                &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;New client connected...\n&quot;</span>);<br>                    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> <span class="hljs-title">client_addr</span>;</span><br>                    <span class="hljs-type">int</span> sizeof_client_addr = <span class="hljs-keyword">sizeof</span>(client_addr);<br>                    <span class="hljs-type">int</span> client_sock = accept(server_sock,&amp;client_addr,&amp;sizeof_client_addr);<br><br>                    <span class="hljs-comment">//将客户端的socket加入到总的fd_set中，就可以使用select查询处理</span><br>                    FD_SET(client_sock,&amp;fd_reads);<br>                    <br>                    <span class="hljs-comment">//更新最大值，因为select监听的sockt是从0~fd_max  </span><br>                    fd_max = (client_sock &gt; fd_max) ? client_sock : fd_max;<br>                &#125;<br>                <span class="hljs-keyword">else</span><span class="hljs-comment">//说明有客户端数据进来</span><br>                &#123;<br>                    <span class="hljs-type">const</span> <span class="hljs-type">int</span> message_size = <span class="hljs-number">30</span>;<br>                    <span class="hljs-type">char</span> message[message_size];<br><br>                    <span class="hljs-type">int</span> read_size;<br>                    read_size = read(i,message,message_size);<br><br>                    <span class="hljs-keyword">if</span> (read_size == <span class="hljs-number">0</span>)<span class="hljs-comment">//说明客户端请求关闭连接</span><br>                    &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Close client...\n&quot;</span>);<br>                        FD_CLR(i,&amp;fd_reads);<span class="hljs-comment">//踢出监控集合</span><br>                        close(i);<span class="hljs-comment">//再关闭连接</span><br>                    &#125;<br>                    <span class="hljs-keyword">else</span><span class="hljs-comment">//收到数据，选择给它回发过去</span><br>                    &#123;<br>                        message[read_size] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Receive message is %s.\n&quot;</span>,message);<br>                        write(i,message,read_size);<br>                    &#125;<br>                &#125;<br>            &#125; <br>        &#125;  <br>    &#125;<br><br>    close(server_sock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>TCP/IP网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>protocbuf C+++示例</title>
    <link href="/2024/11/04/protocbuf/"/>
    <url>/2024/11/04/protocbuf/</url>
    
    <content type="html"><![CDATA[<h1 id="protocbuf-c-示例"><a href="#protocbuf-c-示例" class="headerlink" title="protocbuf c++示例"></a>protocbuf c++示例</h1><p>Protocol Buffers（简称Protobuf）是由Google开发的一种语言中立、平台中立、可扩展的序列化数据格式，可以用于数据存储或RPC（远程过程调用）系统间的数据交换。它类似于XML或JSON，但更小、更快、更简单。</p><p><strong>Protobuf的主要特点包括：</strong></p><ol><li>高效：<br> 空间效率：Protobuf使用二进制格式存储数据，比XML和JSON更节省空间。<br> 时间效率：解析和序列化速度更快，适合高性能应用。</li><li>语言中立：<br>支持多种编程语言，包括C++、Java、Python、Go、Ruby、JavaScript、C#等，便于跨语言、跨平台的数据交换。</li><li>自动代码生成：<br> 通过.proto文件定义数据结构后，Protobuf编译器（protoc）可以自动生成相应语言的源代码，包括数据访问类和方法。</li><li>向后兼容性：<br> 支持数据的向前和向后兼容性，可以在不破坏现有系统的情况下添加或删除字段。</li><li>扩展性强：<br>-可以方便地添加新的数据类型和字段，而不会破坏已经存在的系统。</li><li>平台无关：<br>可以在不同平台上使用，无论是服务器、客户端还是嵌入式系统。</li></ol><h2 id="1-关键字"><a href="#1-关键字" class="headerlink" title="1.关键字"></a>1.关键字</h2><ol><li>required:必须在序列化后的消息中设置该字段的值，如果未设置，则该消息不能被序列化(protoc3时已被删除使用)。</li><li>optional:表示该字段为可选字段，可以有值也可以没有值（默认值为定义字段时指定的默认值，如果没有指定默认值，则为特定类型的默认值，例如对于数字类型是0，对于字符串类型是空字符串）。</li><li>repeated:表示该字段可以包含0个或多个元素，类似于C++中的std::vector。</li><li>map：这是一个配对键&#x2F;值字段类型。</li></ol><h2 id="2-保留字段"><a href="#2-保留字段" class="headerlink" title="2.保留字段"></a>2.保留字段</h2><h3 id="2-1-前置条件"><a href="#2-1-前置条件" class="headerlink" title="2.1 前置条件"></a>2.1 前置条件</h3><ul><li>如果操作不当，删除字段可能会导致严重问题。</li><li>当不再需要某个字段且已从客户端代码中删除所有引用时，可以从消息中删除该字段定义。但是，必须- 保留已删除的字段号。如果不保留字段号，开发人员将来有可能重新使用该字段号。</li><li>还应保留字段名称，以允许消息的 JSON 和 TextFormat 编码继续进行解析。</li></ul><h3 id="2-2-执行方案"><a href="#2-2-执行方案" class="headerlink" title="2.2 执行方案"></a>2.2 执行方案</h3><ul><li><p>如果通过完全删除字段或将其注释掉来更新消息类型，则未来的开发人员可以在对类型进行自己的更新时重新使用该字段号。重复使用字段编号会使解码线格式消息变得模棱两可。<br>protobuf 线格式精简，无法检测使用一种定义编码并使用另一种定义解码的字段。</p></li><li><p>为确保这种情况不会发生，请将已删除的字段号添加到 reserved 列表中。为确保消息的 JSON 和 TextFormat 实例仍可解析，还应将已删除的字段名称添加到 reserved 列表中。</p></li><li><p>如果任何未来的开发人员尝试使用这些保留的字段号或名称，则协议缓冲区编译器会发出警告。</p></li></ul><h3 id="2-3-使用示例"><a href="#2-3-使用示例" class="headerlink" title="2.3 使用示例"></a>2.3 使用示例</h3><figure class="highlight proto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs proto"><span class="hljs-keyword">message </span><span class="hljs-title class_">Foo</span> &#123;<br>  reserved <span class="hljs-number">2</span>, <span class="hljs-number">15</span>, <span class="hljs-number">9</span> to <span class="hljs-number">11</span>;<br>  reserved <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-注意事项"><a href="#2-4-注意事项" class="headerlink" title="2.4 注意事项"></a>2.4 注意事项</h3><ul><li>保留的字段号范围是包含的（9 到 11 与 9、10、11 相同）。请注意，不能在同一个 reserved 语句中混合字段名称和字段号。</li></ul><h2 id="3-枚举"><a href="#3-枚举" class="headerlink" title="3. 枚举"></a>3. 枚举</h2><h3 id="3-1-有别于C-的一点"><a href="#3-1-有别于C-的一点" class="headerlink" title="3.1 有别于C++的一点"></a>3.1 有别于C++的一点</h3><ul><li>各字段之间统一使用分号(;)隔开，第一个字段对应的常量值必须是零。</li></ul><h3 id="3-2-使用不同的枚举常量表示相同的值之前，需要更改配置"><a href="#3-2-使用不同的枚举常量表示相同的值之前，需要更改配置" class="headerlink" title="3.2 使用不同的枚举常量表示相同的值之前，需要更改配置"></a>3.2 使用不同的枚举常量表示相同的值之前，需要更改配置</h3><ul><li>需要将option 中的 allow_alias 设置为true;</li></ul><h3 id="3-3-相关事项"><a href="#3-3-相关事项" class="headerlink" title="3.3 相关事项"></a>3.3 相关事项</h3><ol><li>枚举常量必须在32位整数的范围内。</li><li>负值效率低下，不推荐使用。</li><li>可以在消息定义中定义 enum，也可以在外部定义，外部定义的这些enum可以重复用于 .proto 文件中的任何消息定义。</li><li>可以使用在一个消息中声明的enum类型作为另一个消息(message)中字段的类型，使用语法 <em>MessageType</em>._EnumType_。</li></ol><h3 id="3-4-注意删除时保留字段的问题，同message"><a href="#3-4-注意删除时保留字段的问题，同message" class="headerlink" title="3.4 注意删除时保留字段的问题，同message"></a>3.4 注意删除时保留字段的问题，同message</h3><h3 id="3-5-使用示例"><a href="#3-5-使用示例" class="headerlink" title="3.5 使用示例"></a>3.5 使用示例</h3><figure class="highlight proto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs proto"><span class="hljs-keyword">enum </span><span class="hljs-title class_">Sex</span>&#123;<br>    <span class="hljs-keyword">option</span> allow_alias = ture;<span class="hljs-comment">//允许使用多个常量表示相同的值</span><br>    MAN = <span class="hljs-number">0</span>;<br>    MEN = <span class="hljs-number">0</span>;<br>    MOMAN = <span class="hljs-number">1</span>;<br>    WOMEN = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-命名空间"><a href="#4-命名空间" class="headerlink" title="4. 命名空间"></a>4. 命名空间</h2><h3 id="4-1-使用关键字package设置命名空间"><a href="#4-1-使用关键字package设置命名空间" class="headerlink" title="4.1 使用关键字package设置命名空间"></a>4.1 使用关键字package设置命名空间</h3><h3 id="4-2-使用示例"><a href="#4-2-使用示例" class="headerlink" title="4.2 使用示例"></a>4.2 使用示例</h3><figure class="highlight proto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs proto"><span class="hljs-keyword">package</span> PersonalMessage;<span class="hljs-comment">//生成的c++代码将处于命名空间PersonalMessage中</span><br></code></pre></td></tr></table></figure><h2 id="5-导入定义import"><a href="#5-导入定义import" class="headerlink" title="5. 导入定义import"></a>5. 导入定义import</h2><p>类似于#include的功能。</p><h2 id="6-编译指令"><a href="#6-编译指令" class="headerlink" title="6. 编译指令"></a>6. 编译指令</h2><blockquote><p>protoc -I&#x3D;$SRC_DIR  –cpp_out&#x3D;$DST_DIR  $SRC_DIR&#x2F;Person.proto</p></blockquote><ul><li><p>-I&#x3D;$SRC_DIR:指定.proto文件所在位置，不指定则默认当前位置；</p></li><li><p>–cpp_out&#x3D;$DST_DIR：指定生成源码放置的位置；</p></li><li><p>$SRC_DIR&#x2F;Person.proto:指定要操作的.proto文件</p></li><li><p>person.pb.h:声明生成的类的头文件</p></li><li><p>person.pb.cc:包含生成类的实现</p></li></ul><h2 id="7-protoc使用示例"><a href="#7-protoc使用示例" class="headerlink" title="7. protoc使用示例"></a>7. protoc使用示例</h2><h3 id="7-1-proto文件"><a href="#7-1-proto文件" class="headerlink" title="7.1 .proto文件"></a>7.1 .proto文件</h3><ul><li><p>Person.proto文件演示了如何使用protoc生成c++代码，编译指令：</p><blockquote><p>protoc –cpp_out&#x3D;. .&#x2F;Person.proto </p></blockquote></li><li><p>编译成功会在当前目录生成person.pb.h和person.pb.cc</p><figure class="highlight proto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs proto">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">package</span> PersonalMessage;<br><br><span class="hljs-keyword">enum </span><span class="hljs-title class_">Sex</span>&#123;<br>    <span class="hljs-keyword">option</span> allow_alias = <span class="hljs-literal">true</span>;<span class="hljs-comment">//允许使用多个常量表示相同的值</span><br>    MAN = <span class="hljs-number">0</span>;<br>    MEN = <span class="hljs-number">0</span>;<br>    MOMAN = <span class="hljs-number">1</span>;<br>    WOMEN = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">optional</span> <span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;<span class="hljs-comment">//姓名</span><br>    <span class="hljs-keyword">optional</span> <span class="hljs-type">int32</span> age = <span class="hljs-number">2</span>;<span class="hljs-comment">//年龄</span><br>    <span class="hljs-keyword">optional</span> Sex sex = <span class="hljs-number">3</span>;<span class="hljs-comment">//性别</span><br>    <span class="hljs-keyword">optional</span> <span class="hljs-type">string</span> address = <span class="hljs-number">4</span>;<span class="hljs-comment">//地址</span><br>    <span class="hljs-keyword">optional</span> <span class="hljs-type">string</span> email = <span class="hljs-number">5</span>;<span class="hljs-comment">//邮箱</span><br>    <span class="hljs-keyword">optional</span> <span class="hljs-type">bool</span> is_married = <span class="hljs-number">6</span>;<span class="hljs-comment">//婚姻</span><br>    <span class="hljs-keyword">repeated</span> Phone phones = <span class="hljs-number">7</span>;<span class="hljs-comment">//电话号码集</span><br><br>    <span class="hljs-keyword">enum </span><span class="hljs-title class_">PhoneType</span>&#123;<br>        PHONE_TYPE_HOME = <span class="hljs-number">0</span>;<br>        PHONE_TYPE_WORK = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">message </span><span class="hljs-title class_">Phone</span>&#123;<br>        <span class="hljs-keyword">optional</span> <span class="hljs-type">string</span> number = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">optional</span> PhoneType phoentype = <span class="hljs-number">2</span>;<br>    &#125;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="7-2-序列化cpp代码"><a href="#7-2-序列化cpp代码" class="headerlink" title="7.2 序列化cpp代码"></a>7.2 序列化cpp代码</h3><ul><li>write.cpp 演示了将内容序列化成二进制文件并存入相应文件中，编译指令：<blockquote><p>g++ write.cpp Person.pb.cc -I. -lprotocbuf -o write</p></blockquote></li><li>编译成功会在当前目录下生成名为write的可执行文件 执行指令：.&#x2F;write<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Person.pb.h&quot;</span></span><br><br>using namespace PersonalMessage;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span><br>&#123;<br><br>    GOOGLE_PROTOBUF_VERIFY_VERSION;<br>    Person person;<br>    person.set_name(<span class="hljs-string">&quot;alang&quot;</span>);<br>    person.set_age(<span class="hljs-number">18</span>);<br>    person.set_sex(Sex::MAN);<br>    person.set_email(<span class="hljs-string">&quot;3271405xxx@qq.com&quot;</span>);<br>    person.set_is_married(<span class="hljs-literal">false</span>);<br>    person.set_address(<span class="hljs-string">&quot;amoy&quot;</span>);<br><br>   <span class="hljs-comment">// 添加第一个电话号码  </span><br>    Person::Phone* phone1 = person.add_phones();  <br>    phone1-&gt;set_number(<span class="hljs-string">&quot;1500857xxxx&quot;</span>);  <br>    phone1-&gt;set_phoentype(Person::PHONE_TYPE_WORK); <br><br>    <span class="hljs-comment">// 添加第二个电话号码，并设置类型为家庭电话  </span><br>    Person::Phone* phone2 = person.add_phones();  <br>    phone2-&gt;set_number(<span class="hljs-string">&quot;1955922xxxx&quot;</span>);<br>    phone2-&gt;set_phoentype(Person::PHONE_TYPE_HOME); <br><br>    <span class="hljs-built_in">std</span>::fstream <span class="hljs-title function_">output</span><span class="hljs-params">(<span class="hljs-string">&quot;person.bin&quot;</span>, <span class="hljs-built_in">std</span>::ios::out | <span class="hljs-built_in">std</span>::ios::binary)</span>;  <br>    <span class="hljs-keyword">if</span> (!output) &#123;  <br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;无法打开文件用于写入&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 序列化Person对象到文件流  </span><br>    <span class="hljs-keyword">if</span> (!person.SerializeToOstream(&amp;output)) &#123;  <br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;序列化到文件失败&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    &#125;  <br>  <br>    output.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="7-3-反序列化cpp代码"><a href="#7-3-反序列化cpp代码" class="headerlink" title="7.3 反序列化cpp代码"></a>7.3 反序列化cpp代码</h3><ul><li>read.cpp 演示了将内容序列化成二进制文件并存入相应文件中，编译指令：<blockquote><p>g++ read.cpp Person.pb.cc -I. -lprotocbuf -o read</p></blockquote></li><li>编译成功会在当前目录下生成名为read的可执行文件 执行指令：.&#x2F;read</li><li>代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Person.pb.h&quot;</span></span><br><br>using namespace PersonalMessage;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span><br>&#123;<br><br>    GOOGLE_PROTOBUF_VERIFY_VERSION;<br>    Person person;<br><br>    <span class="hljs-built_in">std</span>::fstream <span class="hljs-title function_">input</span><span class="hljs-params">(<span class="hljs-string">&quot;person.bin&quot;</span>, <span class="hljs-built_in">std</span>::ios::in | <span class="hljs-built_in">std</span>::ios::binary)</span>;  <br>    <span class="hljs-keyword">if</span> (!input) &#123;  <br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;无法打开文件用于读出&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 序列化Person对象到文件流  </span><br>    <span class="hljs-keyword">if</span> (!person.ParseFromIstream(&amp;input)) &#123;  <br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;反序列化到文件失败&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    &#125;  <br>    <br>    input.close();<br><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;name:&quot;</span> &lt;&lt; person.name() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;age:&quot;</span> &lt;&lt; person.age() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;address:&quot;</span> &lt;&lt; person.address() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;email:&quot;</span> &lt;&lt; person.email() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; person.phones_size(); i++)<br>    &#123;<br>        Person::Phone phone = person.phones(i);<br>        <span class="hljs-keyword">switch</span> (phone.phoentype())<br>        &#123;<br>        <span class="hljs-keyword">case</span> Person::PHONE_TYPE_HOME:<br>            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;居家使用的电话号码:&quot;</span> &lt;&lt; phone.number() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> Person::PHONE_TYPE_WORK:<br>            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;公司使用的电话号码:&quot;</span> &lt;&lt; phone.number() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li>程序输出：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">name:alang</span><br><span class="hljs-section">age:18</span><br><span class="hljs-section">address:amoy</span><br><span class="hljs-section">email:3271405xxx@qq.com</span><br><span class="hljs-section">公司使用的电话号码:1500857xxxx</span><br><span class="hljs-section">居家使用的电话号码:1955922xxxx</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="代码仓库：gitee仓库地址"><a href="#代码仓库：gitee仓库地址" class="headerlink" title="代码仓库：gitee仓库地址"></a>代码仓库：<a href="https://gitee.com/alang_robot/g-rpclearning/tree/master/protocbuf">gitee仓库地址</a></h1><h1 id="参考链接：官方示例"><a href="#参考链接：官方示例" class="headerlink" title="参考链接：官方示例"></a>参考链接：<a href="https://protobuf.com.cn/getting-started/cpptutorial/">官方示例</a></h1>]]></content>
    
    
    <categories>
      
      <category>C++随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>世界上最好的语言.cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈I/O复用模型之epoll模型</title>
    <link href="/2024/11/04/epoll/"/>
    <url>/2024/11/04/epoll/</url>
    
    <content type="html"><![CDATA[<h1 id="I-O多路复用之epoll模型"><a href="#I-O多路复用之epoll模型" class="headerlink" title="I&#x2F;O多路复用之epoll模型"></a>I&#x2F;O多路复用之epoll模型</h1><h2 id="1-先谈谈select模型和poll模型的问题"><a href="#1-先谈谈select模型和poll模型的问题" class="headerlink" title="1 先谈谈select模型和poll模型的问题"></a>1 先谈谈select模型和poll模型的问题</h2><ol><li>由于select模型中，socket是由一个32个元素的int型数组中元素的二进制位存储的(位图存储)，所以就有一个最大值的限定，在32位的系统中数量为32 * 4 * 8 &#x3D; 1024;poll模型为了解决这个问题，使用了链表结构存储socket。</li><li>除了上述的问题，poll模型和select模型都存在以下两个很大程度上影响性能的问题：</li></ol><ul><li>在调用select()函数或poll()函数之后，都要循环遍历所有socket查找需要处理的socket;</li><li>在调用sele()函数或poll()函数之前，都需要传递所有监视对象的信息。</li></ul><ol start="3"><li>为了解决上述两个问题，我们需要重新构造一种I&#x2F;O复用模型，这个模型必须满足两点：</li></ol><ul><li>在监视范围发生变化时，只返回产生变化的对应socket;</li><li>只传递以此监视对象。</li></ul><h2 id="2-epoll模型"><a href="#2-epoll模型" class="headerlink" title="2 epoll模型"></a>2 epoll模型</h2><p>epoll模型的出现是为了解决select和poll模型留下的缺陷，使用epoll模型搭建服务器涉及到以下三个函数,函数原型分别如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">epoll_create</span> <span class="hljs-params">(<span class="hljs-type">int</span> __size)</span> __THROW;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">epoll_ctl</span> <span class="hljs-params">(<span class="hljs-type">int</span> __epfd, <span class="hljs-type">int</span> __op, <span class="hljs-type">int</span> __fd,</span><br><span class="hljs-params">      <span class="hljs-keyword">struct</span> epoll_event *__event)</span> __THROW;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">epoll_wait</span> <span class="hljs-params">(<span class="hljs-type">int</span> __epfd, <span class="hljs-keyword">struct</span> epoll_event *__events,</span><br><span class="hljs-params">       <span class="hljs-type">int</span> __maxevents, <span class="hljs-type">int</span> __timeout)</span>;<br></code></pre></td></tr></table></figure><p><strong>1. epoll_create</strong><br><strong>参数：</strong></p><ul><li>__size：这个参数在早期的Linux版本中用来指定监听的文件描述符的数量上限，但在Linux 2.6.8及以后的版本中，这个参数被忽略，因为内核会根据需要动态地分配资源。不过，为了兼容性和代码可读性，通常还是会传递一个合理的值。<br><strong>返回值：</strong></li><li>成功时返回一个新的文件描述符（epoll实例），用于后续的epoll_ctl和epoll_wait调用。<br>失败时返回-1，并设置errno以指示错误。<br><strong>使用方法：</strong></li><li>调用epoll_create创建一个epoll实例。</li><li>使用返回的文件描述符作为epoll_ctl和epoll_wait的第一个参数。<br><strong>2. epoll_ctl</strong></li></ul><p><strong>参数：</strong></p><ul><li>__epfd：由epoll_create返回的文件描述符。</li><li>__op：要执行的操作，可以是以下三个值之一：</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> EPOLL<span class="hljs-emphasis">_CTL_</span>ADD：添加一个新的文件描述符到epoll实例中。<br><span class="hljs-bullet">-</span> EPOLL<span class="hljs-emphasis">_CTL_</span>MOD：修改已存在的文件描述符的事件监听设置。<br><span class="hljs-bullet">-</span> EPOLL<span class="hljs-emphasis">_CTL_</span>DEL：从epoll实例中删除一个文件描述符。<br></code></pre></td></tr></table></figure><ul><li>__fd：要添加、修改或删除的文件描述符。</li><li>__event：指向一个epoll_event结构的指针，该结构指定了要监听的事件类型（如读就绪、写就绪等）和与该文件描述符关联的数据（通常用于区分不同的事件源）。<br><strong>返回值：</strong></li><li>成功时返回0。</li><li>失败时返回-1，并设置errno以指示错误。<br><strong>使用方法：</strong></li><li>使用EPOLL_CTL_ADD将新的文件描述符添加到epoll实例中。</li><li>使用EPOLL_CTL_MOD修改已存在的文件描述符的监听设置。</li><li>使用EPOLL_CTL_DEL从epoll实例中删除文件描述符。<br><strong>3. epoll_wait</strong><br><strong>参数：</strong></li><li>__epfd：由epoll_create返回的文件描述符。</li><li>__events：指向一个epoll_event数组的指针，该数组用于存储从epoll实例中返回的事件。</li><li>__maxevents：__events数组的大小，即最多可以返回的事件数量。</li><li>__timeout：等待事件的超时时间（毫秒）。如果为-1，则表示无限等待，直到有事件发生。如果为0，则立即返回，不管是否有事件发生。<br><strong>返回值：</strong></li><li>成功时返回发生的事件数量。</li><li>如果超时且没有事件发生，则返回0。</li><li>失败时返回-1，并设置errno以指示错误。<br><strong>使用方法：</strong></li><li>调用epoll_wait等待事件的发生。</li><li>如果有事件发生，epoll_wait会将事件信息填充到__events数组中，并返回发生的事件数量。</li><li>遍历__events数组，处理每个事件。</li></ul><h2 id="3-epoll模型服务器实例"><a href="#3-epoll模型服务器实例" class="headerlink" title="3 epoll模型服务器实例"></a>3 epoll模型服务器实例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LISTEN_NUM 10</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_handing</span><span class="hljs-params">(<span class="hljs-type">char</span> *message)</span><br>&#123;<br>    <span class="hljs-built_in">fputs</span>(message,<span class="hljs-built_in">stderr</span>);<br>    fputc(<span class="hljs-string">&#x27;\n&#x27;</span>,<span class="hljs-built_in">stderr</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span><br>&#123;<br>    <span class="hljs-comment">//步骤1：创建套接字</span><br>    <span class="hljs-type">int</span> server_sock;<br>    server_sock = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);<br>    <span class="hljs-keyword">if</span> (server_sock == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;socket() error&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//步骤2：绑定监听端口</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_addr</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;server_addr,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(server_addr));<br>    server_addr.sin_family = AF_INET;<br>    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);<br>    server_addr.sin_port = htons(atoi(<span class="hljs-string">&quot;3333&quot;</span>));<br>    <span class="hljs-keyword">if</span> (bind(server_sock,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;server_addr,<span class="hljs-keyword">sizeof</span>(server_addr)) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;bind() error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//步骤3：开启监听</span><br>    <span class="hljs-keyword">if</span> (listen(server_sock,LISTEN_NUM) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        error_handing(<span class="hljs-string">&quot;listen() error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//步骤4：做epoll_create()调用之前的准备</span><br><br>    <span class="hljs-type">int</span> epoll_fd;<span class="hljs-comment">//epoll实例</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> *<span class="hljs-title">epoll_events</span>;</span><span class="hljs-comment">//用于接收激活链表中的事件</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">epoll_event</span>;</span><span class="hljs-comment">//用于加入事件</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> events_num = <span class="hljs-number">999</span>;<br>    epoll_events = (<span class="hljs-keyword">struct</span> epoll_event *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> epoll_event) * events_num);<br><br>    <span class="hljs-comment">//步骤5：调用epoll_create()初始化epoll实例</span><br>    epoll_fd = epoll_create(<span class="hljs-number">1</span>); <span class="hljs-comment">//可以忽略这个参数，填入的参数为操作系统参考</span><br>   <br>    <span class="hljs-comment">// 将服务器套接字加入 epoll 监听</span><br>    epoll_event.events = EPOLLIN; <span class="hljs-comment">//需要读取数据的情况</span><br>    epoll_event.data.fd = server_sock;<br><br>    <span class="hljs-comment">//例程epoll_fd中添加文件描述符server_sock，之后epoll_fd就会监听server_sock的EPOLLIN事件</span><br>    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, server_sock, &amp;epoll_event); <br><br>    <span class="hljs-type">int</span> event_count;<span class="hljs-comment">//激活事件计数</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">//步骤5：调用epoll_wait()函数等待激活事件出现</span><br>        event_count = epoll_wait(epoll_fd, epoll_events, events_num, <span class="hljs-number">-1</span>); <span class="hljs-comment">//获取改变了的文件描述符，返回数量,-1表示永久等待</span><br>        <span class="hljs-keyword">if</span> (event_count == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;epoll_wait() error\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//步骤6：处理激活事件</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; event_count; i++)<br>        &#123;<br>            <span class="hljs-comment">//如果是服务器套接字的事件</span><br>            <span class="hljs-keyword">if</span> (epoll_events[i].data.fd == server_sock)<span class="hljs-comment">//客户端请求连接时</span><br>            &#123;<br><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> <span class="hljs-title">client_addr</span>;</span><br>                <span class="hljs-type">int</span> client_addr_size = <span class="hljs-keyword">sizeof</span>(client_addr);<br>                <span class="hljs-type">int</span> client_sock;<br>                <span class="hljs-comment">// 接受客户端连接</span><br>                client_sock = accept(server_sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client_addr, &amp;client_addr_size);<br><br>                epoll_event.events = EPOLLIN;<br><br>                <span class="hljs-comment">//epoll_event.events = EPOLLIN | EPOLLET;设置为边缘触发模式</span><br><br>                <span class="hljs-comment">//设置为非阻塞模式</span><br>                <span class="hljs-comment">// int flags = fcntl(client_sock, F_GETFL, 0);</span><br>                <span class="hljs-comment">// if (fcntl(client_sock, F_SETFL, flags | O_NONBLOCK) == -1) &#123;</span><br>                <span class="hljs-comment">//     perror(&quot;fcntl()&quot;);</span><br>                <span class="hljs-comment">//     exit(EXIT_FAILURE);</span><br>                <span class="hljs-comment">// &#125;</span><br><br>                epoll_event.data.fd = client_sock; <span class="hljs-comment">//把客户端套接字添加进去</span><br>                epoll_ctl(epoll_fd, EPOLL_CTL_ADD, client_sock, &amp;epoll_event);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Connected client... %d \n&quot;</span>, client_sock);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">//是客户端套接字时</span><br>            &#123;<br>                <span class="hljs-type">const</span> <span class="hljs-type">int</span> message_size =<span class="hljs-number">30</span>;<br>                <span class="hljs-type">char</span> message[message_size];<br>                <span class="hljs-type">int</span> read_nums = read(epoll_events[i].data.fd, message, message_size);<br>                <span class="hljs-keyword">if</span> (read_nums == <span class="hljs-number">0</span>)<br>                &#123;<br>                    epoll_ctl(epoll_fd, EPOLL_CTL_DEL, epoll_events[i].data.fd, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">//从epoll中删除套接字</span><br>                    close(epoll_events[i].data.fd);<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Closed client : %d \n&quot;</span>, epoll_events[i].data.fd);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-comment">// 读取数据并回传给客户端</span><br>                &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Receive message is %s\n&quot;</span>,message);<br>                    write(epoll_events[i].data.fd, message, read_nums);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//步骤7：关闭套接字和epoll实例</span><br>    close(server_sock);<br>    close(epoll_fd);<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="4-关于边缘触发和水平触发（条件触发）"><a href="#4-关于边缘触发和水平触发（条件触发）" class="headerlink" title="4 关于边缘触发和水平触发（条件触发）"></a>4 关于边缘触发和水平触发（条件触发）</h2><ol><li>定义区别：</li></ol><ul><li>水平触发（Level Triggered）是只要输入缓冲区有数据，就会一直通知该事件，假设输入缓冲区中有数据，就会注册一次事件，读取之后缓冲区还剩余数据，就会再次注册输入事件；</li><li>边缘触发（Edge Triggered）是只有输入缓冲区收到数据时通知一次事件，即使拂去之后缓冲区里面还剩余数据，也不会注册事件。</li></ul><ol start="2"><li>效率区别：</li></ol><ul><li>水平触发由于每次文件描述符就绪时都会通知应用程序，因此可能会引起频繁的上下文切换，影响效率；</li><li>边缘触发只在状态变化时通知应用程序，可以减少不必要的上下文切换，提高效率，特别适合处理大量事件和高并发的场景。</li></ul><ol start="3"><li>适用场景区别：</li></ol><ul><li>水平触发适用于对实时性要求不是非常高的应用，例如普通的网络服务器或者需要周期性处理数据的情况，适合处理一般的数据读取、写入等操作；</li><li>边缘触发适用于对事件响应速度要求较高的应用，例如高性能网络服务器，需要快速处理大量连接或数据的情况，适合处理大数据流、高并发请求等场景，可以减少因为频繁通知而引起的性能开销。</li></ul><ol start="4"><li>使用事项：</li></ol><ul><li>epoll模型默认使用的是水平触发模式，select模型使用的也是水平触发模式；</li><li>更改为边缘触发模式需要确保一次将缓冲区的数据读完，如果以阻塞方式读取或写入数据，可能会导致服务器或客户端长时间停顿，所以使用边缘触发模式时最好更改为非阻塞I&#x2F;O。</li></ul><h2 id="关于边缘触发的实例修改建议"><a href="#关于边缘触发的实例修改建议" class="headerlink" title="关于边缘触发的实例修改建议"></a>关于边缘触发的实例修改建议</h2><ol><li>更改事件触发方式为边缘触发<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">epoll_event.events = EPOLLIN | EPOLLET;<br></code></pre></td></tr></table></figure></li><li>更改客户端socket为非阻塞I&#x2F;O模式<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-comment">//sockfd为客户端socket</span><br><span class="hljs-type">int</span> flags = fcntl(sockfd, F_GETFL, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (fcntl(sockfd, F_SETFL, flags | O_NONBLOCK) == <span class="hljs-number">-1</span>) &#123;<br>    perror(<span class="hljs-string">&quot;fcntl()&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h2 id="边缘触发优于水平触发的一点"><a href="#边缘触发优于水平触发的一点" class="headerlink" title="边缘触发优于水平触发的一点"></a>边缘触发优于水平触发的一点</h2><p><strong>边缘触发可以分离接收数据和处理数据的时间点</strong></p><ul><li>如果是水平触发，输入缓冲区收到了数据，就要求读取数据，否则将会一直注册事件，这是不必要的；</li><li>如果是边缘触发的话，即使服务器输入缓冲区收到了数据，服务器也能决定处理数据的时间点，这样带来了极大的灵活性。</li></ul>]]></content>
    
    
    <categories>
      
      <category>TCP/IP网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++深浅拷贝</title>
    <link href="/2024/11/04/C++%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <url>/2024/11/04/C++%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是浅拷贝？"><a href="#什么是浅拷贝？" class="headerlink" title="什么是浅拷贝？"></a>什么是浅拷贝？</h1><p>C++ 类如果没有自定义拷贝构造函数或者自定义赋值操作符而使用拷贝构造或者赋值操作符，这时候就会涉及到浅拷贝的问题。</p><h1 id="浅拷贝导致的问题"><a href="#浅拷贝导致的问题" class="headerlink" title="浅拷贝导致的问题"></a>浅拷贝导致的问题</h1><p>浅拷贝遇到需要动态申请的内存时，只会将新的变量指针指向被拷贝的内存，导致两个变量同时管理一个内存，进而产生一系列问题：</p><h2 id="1-双重释放问题"><a href="#1-双重释放问题" class="headerlink" title="1. 双重释放问题"></a>1. 双重释放问题</h2><p>原对象和被拷贝出来的对象离开生存空间时，双双调用析构函数释放同一块内存，会导致double free 问题；<br><strong>double free 示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class">&#123;</span><br>public:<br>    Person(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (name)<br>        &#123;<br>            name_ = new <span class="hljs-type">char</span>(<span class="hljs-built_in">strlen</span>(name) + <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">strcpy</span>(name_,name);<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">//打印名字</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">PrintName</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">if</span>(name_)&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;name:&quot;</span> &lt;&lt; name_ &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;&#125;;<br>    ~Person()<br>    &#123;  <br>        delete[] name_;<span class="hljs-comment">//释放内存</span><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Person destructor.&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;;<br><br>    <span class="hljs-comment">//需要动态申请的内存变量，但是没有自定义copy 构造函数和赋值运算符</span><br>private:<br>    <span class="hljs-type">char</span> *name_;<br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span><br>&#123;<br>    Person <span class="hljs-title function_">person1</span><span class="hljs-params">(<span class="hljs-string">&quot;alang&quot;</span>)</span>;<br><br>    person1.PrintName();<br>    Person <span class="hljs-title function_">person2</span><span class="hljs-params">(person1)</span>;<span class="hljs-comment">//调用的是编译器自动生成的copy构造</span><br>    person2.PrintName();<br>    <br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;接下来开始调用析构函数回收内存&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>程序输出</strong></p><figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs irpf90"><span class="hljs-keyword">name</span>:alang<br><span class="hljs-keyword">name</span>:alang<br>接下来开始调用析构函数回收内存<br>Person destructor.<br><span class="hljs-keyword">free</span>(): <span class="hljs-keyword">double</span> <span class="hljs-keyword">free</span> detected <span class="hljs-keyword">in</span> tcache <span class="hljs-number">2</span><br>Aborted<br></code></pre></td></tr></table></figure><h2 id="2-程序逻辑错误"><a href="#2-程序逻辑错误" class="headerlink" title="2. 程序逻辑错误"></a>2. 程序逻辑错误</h2><p>当拷贝对象之一离开自己的生存空间时，会调用析构函数，会将同时管理的内存释放掉，导致其余对象去操作一个已经被释放的内存，同时也会存在双重释放问题<br><strong>示例1：较上面只有main函数的更改</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span><br>&#123;<br>    Person <span class="hljs-title function_">person1</span><span class="hljs-params">(<span class="hljs-string">&quot;alang&quot;</span>)</span>;<br><br>    <span class="hljs-comment">//大括号表示新的生存空间</span><br>    &#123;<br>        Person <span class="hljs-title function_">person2</span><span class="hljs-params">(person1)</span>;<span class="hljs-comment">//调用的是编译器自动生成的copy构造</span><br>        person2.PrintName();<br>    &#125;<br><br>    person1.PrintName();<br>        <br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;接下来开始调用析构函数回收内存&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>最直接的示例是函数使用值传递的方式传递对象时，调用的是copy构造函数来传参的，这样导致函数运行结束之后，浅拷贝的内存被释放掉<br>这里的另一解决方案是：最好不要以值传递的形式传递函数形参，而是引用传递。<br><strong>示例2：较上面只有main函数的更改</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">dosomething</span><span class="hljs-params">(Person p)</span>&#123;&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span><br>&#123;<br>    Person <span class="hljs-title function_">person1</span><span class="hljs-params">(<span class="hljs-string">&quot;alang&quot;</span>)</span>;<br>    dosomething(person1);<br>    person1.PrintName();<br>    <br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;接下来开始调用析构函数回收内存&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="拒绝浅拷贝，使用深拷贝"><a href="#拒绝浅拷贝，使用深拷贝" class="headerlink" title="拒绝浅拷贝，使用深拷贝"></a>拒绝浅拷贝，使用深拷贝</h1><p>在需要对动态内存操作时，不要使用编译器自动生成的拷贝构造函数和赋值运算符</p><p>这种情况下我们有两种方案：</p><ol><li>直接禁用编译器自动生成的函数，直接不允许赋值操作；</li><li>自定义拷贝构造函数和赋值操作符。</li></ol><p>这里给出两种方案的示例：</p><ul><li><strong>禁用，不是很推荐，因为这样丧失了程序的灵活性</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">Person(<span class="hljs-type">const</span> Person &amp;person) = delete;<br>Person&amp; operator=(<span class="hljs-type">const</span> Person &amp;person) = delete;<br></code></pre></td></tr></table></figure></li><li><strong>完善自定义拷贝构造函数和自定义赋值操作符</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class">&#123;</span><br>public:<br><br>    Person():name_(nullptr)&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Person default constructor.&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;;<br>    Person(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (name)<br>        &#123;<br>            name_ = new <span class="hljs-type">char</span>(<span class="hljs-built_in">strlen</span>(name) + <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">strcpy</span>(name_,name);<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">//深拷贝构造函数</span><br>    Person(<span class="hljs-type">const</span> Person &amp;person)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (person.name_)<br>        &#123;<br>            this-&gt;name_ = new <span class="hljs-type">char</span>(<span class="hljs-built_in">strlen</span>(person.name_) + <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">strcpy</span>(this-&gt;name_,person.name_);<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">//深拷贝赋值运算符</span><br>    Person&amp; operator=(<span class="hljs-type">const</span> Person &amp;person)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (person.name_)<br>        &#123;<br>            this-&gt;name_ = new <span class="hljs-type">char</span>(<span class="hljs-built_in">strlen</span>(person.name_) + <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">strcpy</span>(this-&gt;name_,person.name_);<br>        &#125;<br>        <span class="hljs-keyword">return</span> *this;<br>    &#125;<br><br>    <span class="hljs-comment">//打印名字</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">PrintName</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">if</span>(name_)&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;name:&quot;</span> &lt;&lt; name_ &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;&#125;;<br>    ~Person()<br>    &#123;  <br>        delete[] name_;<span class="hljs-comment">//释放内存</span><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Person destructor.&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;;<br><br>    <span class="hljs-comment">//需要动态申请的内存变量，但是没有自定义copy 构造函数和赋值运算符</span><br>private:<br>    <span class="hljs-type">char</span> *name_;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span><br>&#123;<br>    Person <span class="hljs-title function_">person1</span><span class="hljs-params">(<span class="hljs-string">&quot;alang&quot;</span>)</span>;<br>    person1.PrintName();<br>    Person person2;<br>    person2 = person1;<br>    person2.PrintName();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h1 id="Effective-C-条款之二"><a href="#Effective-C-条款之二" class="headerlink" title="Effective C++条款之二"></a>Effective C++条款之二</h1><h2 id="如果不使用编译器自动生成的初始化函数，请明确拒绝它（使用delete）"><a href="#如果不使用编译器自动生成的初始化函数，请明确拒绝它（使用delete）" class="headerlink" title="如果不使用编译器自动生成的初始化函数，请明确拒绝它（使用delete）"></a>如果不使用编译器自动生成的初始化函数，请明确拒绝它（使用delete）</h2><h2 id="如果class内动态配置有内存，请为此class声明一个copy-constructor-和一个assignment运算符"><a href="#如果class内动态配置有内存，请为此class声明一个copy-constructor-和一个assignment运算符" class="headerlink" title="如果class内动态配置有内存，请为此class声明一个copy constructor 和一个assignment运算符"></a>如果class内动态配置有内存，请为此class声明一个copy constructor 和一个assignment运算符</h2>]]></content>
    
    
    <categories>
      
      <category>C++随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>世界上最好的语言.cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
