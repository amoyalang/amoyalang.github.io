<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/11/04/hello-world/"/>
    <url>/2024/11/04/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++深浅拷贝</title>
    <link href="/2024/11/04/C++%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <url>/2024/11/04/C++%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是浅拷贝？"><a href="#什么是浅拷贝？" class="headerlink" title="什么是浅拷贝？"></a>什么是浅拷贝？</h1><p>C++ 类如果没有自定义拷贝构造函数或者自定义赋值操作符而使用拷贝构造或者赋值操作符，这时候就会涉及到浅拷贝的问题。</p><h1 id="浅拷贝导致的问题"><a href="#浅拷贝导致的问题" class="headerlink" title="浅拷贝导致的问题"></a>浅拷贝导致的问题</h1><p>浅拷贝遇到需要动态申请的内存时，只会将新的变量指针指向被拷贝的内存，导致两个变量同时管理一个内存，进而产生一系列问题：</p><h2 id="1-双重释放问题"><a href="#1-双重释放问题" class="headerlink" title="1. 双重释放问题"></a>1. 双重释放问题</h2><p>原对象和被拷贝出来的对象离开生存空间时，双双调用析构函数释放同一块内存，会导致double free 问题；<br><strong>double free 示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class">&#123;</span><br>public:<br>    Person(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (name)<br>        &#123;<br>            name_ = new <span class="hljs-type">char</span>(<span class="hljs-built_in">strlen</span>(name) + <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">strcpy</span>(name_,name);<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">//打印名字</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">PrintName</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">if</span>(name_)&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;name:&quot;</span> &lt;&lt; name_ &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;&#125;;<br>    ~Person()<br>    &#123;  <br>        delete[] name_;<span class="hljs-comment">//释放内存</span><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Person destructor.&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;;<br><br>    <span class="hljs-comment">//需要动态申请的内存变量，但是没有自定义copy 构造函数和赋值运算符</span><br>private:<br>    <span class="hljs-type">char</span> *name_;<br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span><br>&#123;<br>    Person <span class="hljs-title function_">person1</span><span class="hljs-params">(<span class="hljs-string">&quot;alang&quot;</span>)</span>;<br><br>    person1.PrintName();<br>    Person <span class="hljs-title function_">person2</span><span class="hljs-params">(person1)</span>;<span class="hljs-comment">//调用的是编译器自动生成的copy构造</span><br>    person2.PrintName();<br>    <br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;接下来开始调用析构函数回收内存&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>程序输出</strong></p><figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs irpf90"><span class="hljs-keyword">name</span>:alang<br><span class="hljs-keyword">name</span>:alang<br>接下来开始调用析构函数回收内存<br>Person destructor.<br><span class="hljs-keyword">free</span>(): <span class="hljs-keyword">double</span> <span class="hljs-keyword">free</span> detected <span class="hljs-keyword">in</span> tcache <span class="hljs-number">2</span><br>Aborted<br></code></pre></td></tr></table></figure><h2 id="2-程序逻辑错误"><a href="#2-程序逻辑错误" class="headerlink" title="2. 程序逻辑错误"></a>2. 程序逻辑错误</h2><p>当拷贝对象之一离开自己的生存空间时，会调用析构函数，会将同时管理的内存释放掉，导致其余对象去操作一个已经被释放的内存，同时也会存在双重释放问题<br><strong>示例1：较上面只有main函数的更改</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span><br>&#123;<br>    Person <span class="hljs-title function_">person1</span><span class="hljs-params">(<span class="hljs-string">&quot;alang&quot;</span>)</span>;<br><br>    <span class="hljs-comment">//大括号表示新的生存空间</span><br>    &#123;<br>        Person <span class="hljs-title function_">person2</span><span class="hljs-params">(person1)</span>;<span class="hljs-comment">//调用的是编译器自动生成的copy构造</span><br>        person2.PrintName();<br>    &#125;<br><br>    person1.PrintName();<br>        <br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;接下来开始调用析构函数回收内存&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>最直接的示例是函数使用值传递的方式传递对象时，调用的是copy构造函数来传参的，这样导致函数运行结束之后，浅拷贝的内存被释放掉<br>这里的另一解决方案是：最好不要以值传递的形式传递函数形参，而是引用传递。<br><strong>示例2：较上面只有main函数的更改</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">dosomething</span><span class="hljs-params">(Person p)</span>&#123;&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span><br>&#123;<br>    Person <span class="hljs-title function_">person1</span><span class="hljs-params">(<span class="hljs-string">&quot;alang&quot;</span>)</span>;<br>    dosomething(person1);<br>    person1.PrintName();<br>    <br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;接下来开始调用析构函数回收内存&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="拒绝浅拷贝，使用深拷贝"><a href="#拒绝浅拷贝，使用深拷贝" class="headerlink" title="拒绝浅拷贝，使用深拷贝"></a>拒绝浅拷贝，使用深拷贝</h1><p>在需要对动态内存操作时，不要使用编译器自动生成的拷贝构造函数和赋值运算符</p><p>这种情况下我们有两种方案：</p><ol><li>直接禁用编译器自动生成的函数，直接不允许赋值操作；</li><li>自定义拷贝构造函数和赋值操作符。</li></ol><p>这里给出两种方案的示例：</p><ul><li><strong>禁用，不是很推荐，因为这样丧失了程序的灵活性</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">Person(<span class="hljs-type">const</span> Person &amp;person) = delete;<br>Person&amp; operator=(<span class="hljs-type">const</span> Person &amp;person) = delete;<br></code></pre></td></tr></table></figure></li><li><strong>完善自定义拷贝构造函数和自定义赋值操作符</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class">&#123;</span><br>public:<br><br>    Person():name_(nullptr)&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Person default constructor.&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;;<br>    Person(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (name)<br>        &#123;<br>            name_ = new <span class="hljs-type">char</span>(<span class="hljs-built_in">strlen</span>(name) + <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">strcpy</span>(name_,name);<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">//深拷贝构造函数</span><br>    Person(<span class="hljs-type">const</span> Person &amp;person)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (person.name_)<br>        &#123;<br>            this-&gt;name_ = new <span class="hljs-type">char</span>(<span class="hljs-built_in">strlen</span>(person.name_) + <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">strcpy</span>(this-&gt;name_,person.name_);<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">//深拷贝赋值运算符</span><br>    Person&amp; operator=(<span class="hljs-type">const</span> Person &amp;person)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (person.name_)<br>        &#123;<br>            this-&gt;name_ = new <span class="hljs-type">char</span>(<span class="hljs-built_in">strlen</span>(person.name_) + <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">strcpy</span>(this-&gt;name_,person.name_);<br>        &#125;<br>        <span class="hljs-keyword">return</span> *this;<br>    &#125;<br><br>    <span class="hljs-comment">//打印名字</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">PrintName</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">if</span>(name_)&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;name:&quot;</span> &lt;&lt; name_ &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;&#125;;<br>    ~Person()<br>    &#123;  <br>        delete[] name_;<span class="hljs-comment">//释放内存</span><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Person destructor.&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;;<br><br>    <span class="hljs-comment">//需要动态申请的内存变量，但是没有自定义copy 构造函数和赋值运算符</span><br>private:<br>    <span class="hljs-type">char</span> *name_;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span><br>&#123;<br>    Person <span class="hljs-title function_">person1</span><span class="hljs-params">(<span class="hljs-string">&quot;alang&quot;</span>)</span>;<br>    person1.PrintName();<br>    Person person2;<br>    person2 = person1;<br>    person2.PrintName();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h1 id="Effective-C-条款之二"><a href="#Effective-C-条款之二" class="headerlink" title="Effective C++条款之二"></a>Effective C++条款之二</h1><h2 id="如果不使用编译器自动生成的初始化函数，请明确拒绝它（使用delete）"><a href="#如果不使用编译器自动生成的初始化函数，请明确拒绝它（使用delete）" class="headerlink" title="如果不使用编译器自动生成的初始化函数，请明确拒绝它（使用delete）"></a>如果不使用编译器自动生成的初始化函数，请明确拒绝它（使用delete）</h2><h2 id="如果class内动态配置有内存，请为此class声明一个copy-constructor-和一个assignment运算符"><a href="#如果class内动态配置有内存，请为此class声明一个copy-constructor-和一个assignment运算符" class="headerlink" title="如果class内动态配置有内存，请为此class声明一个copy constructor 和一个assignment运算符"></a>如果class内动态配置有内存，请为此class声明一个copy constructor 和一个assignment运算符</h2>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
